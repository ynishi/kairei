use chrono::{DateTime, Utc};

use crate::sistence::types::{RecollectionId, WorkspaceId};

use super::metadata::RecollectionMetadata;

/// A aggregation root of recollection.
pub struct Recollection {
    entries: Vec<(RecollectionEntry, RecollectionMetadata)>,
    workspace_id: Option<WorkspaceId>,
}

/// A record of a memory recollection
#[derive(Clone, Debug)]
pub struct RecollectionEntry {
    /// Unique identifier for this recollection
    pub id: RecollectionId,
    /// Content of the recollection
    pub content: Content,
    /// Context information about the source of this recollection
    pub source_context: SourceContext,
    /// Information about how this recollection was created
    pub creation_info: CreationInfo,
    /// The workspace where this recollection was created, if any
    pub workspace_id: Option<WorkspaceId>,
}

/// Context information about the source of a recollection
#[derive(Clone, Debug)]
pub struct SourceContext {
    /// Source information about where this recollection came from
    source: RecollectionSource,
    /// Timestamp when this recollection was created
    timestamp: DateTime<Utc>,
    /// Related task, if any
    related_task: Option<String>,
}

/// Information about how a recollection was created
#[derive(Clone, Debug)]
pub struct CreationInfo {
    /// ID of the creator (system or agent)
    creator_id: String,
    /// Method used to create this recollection
    creation_method: CreationMethod,
    /// Parent recollections, if any
    parent_ids: Vec<RecollectionId>,
}

/// Source of a recollection
#[derive(Clone, Debug)]
pub enum RecollectionSource {
    /// Statement made by a user
    UserStatement {
        user_id: String,
        statement_type: StatementType,
    },
    /// Observation made by the system
    SystemObservation,
    /// Inference made by the system with confidence level and optional reasoning
    Inference {
        confidence: f32,
        reasoning: Option<String>,
    },
    /// Data from an external API
    ExternalAPI {
        api_name: String,
        request_id: Option<String>,
    },
    /// Synthesized from multiple source recollections
    Synthesis { source_ids: Vec<RecollectionId> },
    /// Generated by an agent
    AgentGenerated {
        agent_id: String,
        generation_context: String,
    },
}

#[derive(Clone, Debug)]
enum StatementType {
    /// Fact
    Fact,
    /// Opinion
    Opinion,
    /// Hypothesis
    Hypothesis,
    /// Question
    Question,
    /// Command
    Command,
    /// Other types of statements
    Other,
}

/// Content of a recollection
#[derive(Clone, Debug)]
pub enum Content {
    /// Text content
    Text(String),
    /// Binary data
    Binary(Vec<u8>),
    /// Structured JSON data
    Structured(serde_json::Value),
    /// Reference to external data (such as API responses)
    Reference(ExternalReference),
}

#[derive(Clone, Debug)]
pub struct ExternalReference {
    /// URL or identifier of the external resource
    url: String,
    /// Type of external resource
    resource_type: ExternalResourceType,
}

#[derive(Clone, Debug)]
pub enum ExternalResourceType {
    /// Web page
    WebPage,
    /// Image
    Image,
    /// Audio file
    Audio,
    /// Video file
    Video,
    /// Document
    Document,
    /// Other types of resources
    Other,
}

/// Method used to create a recollection
#[derive(Clone, Debug)]
pub enum CreationMethod {
    /// Directly created
    Direct,
    /// Derived from other recollections
    Derived,
    /// Created by merging multiple recollections
    Merged { strategy: MergeStrategy },
    /// Imported from an external source
    Imported,
}

#[derive(Clone, Debug)]
pub enum MergeStrategy {
    /// Simple merge of content
    Simple,
    /// Merge with conflict resolution
    ConflictResolution,
    /// Merge with voting
    Voting,
}

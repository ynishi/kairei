use std::collections::HashMap;

use serde::{Deserialize, Serialize};

use crate::{
    config::ProviderConfig,
    provider::{
        config::{
            ErrorContext, ProviderConfigError, ProviderConfigValidator, TypeCheckerValidator,
            ValidationError, config_to_map,
        },
        providers::sistence::SistenceCapability,
    },
};
use serde_valid::Validate;
use serde_valid::json::FromJsonValue;

/// Configuration for SistenceProvider
///
/// This struct contains settings that control the behavior of SistenceProvider,
/// including history management, LLM generation parameters, and default agent capabilities.
///
/// # Examples
///
/// Creating a custom configuration:
///
/// ```ignore,no_run
/// # use kairei_core::provider::config::providers::sistence::SistenceProviderConfig;
/// # use kairei_core::provider::providers::sistence::SistenceCapability;
/// let config = SistenceProviderConfig {
///     max_history_size: 200,
///     default_temperature: 0.8,
///     default_max_tokens: 1000,
///     default_capabilities: vec![
///         SistenceCapability::Notify,
///         SistenceCapability::Suggest,
///         SistenceCapability::Research,
///     ],
/// };
/// ```
///
/// Creating a configuration from a provider config:
///
/// ```ignore
/// let provider_config = some_provider_config();
/// let sistence_config = SistenceProviderConfig::from(&provider_config);
/// ```
#[derive(Debug, Clone, Deserialize, Serialize, Validate)]
pub struct SistenceProviderConfig {
    /// Maximum number of interaction records to keep in agent history
    ///
    /// When this limit is reached, older records are pruned automatically.
    /// Higher values preserve more history but increase memory usage.
    #[validate(minimum = 1)]
    pub max_history_size: usize,

    /// Default temperature parameter for LLM when executing will actions
    ///
    /// Controls the randomness of LLM responses: lower values (e.g., 0.2) produce
    /// more deterministic output, while higher values (e.g., 0.8) produce more creative output.
    #[validate(minimum = 0.0)]
    #[validate(maximum = 1.0)]
    pub default_temperature: f64,

    /// Default maximum token limit for LLM responses
    ///
    /// Limits the length of text generated by the LLM for will actions.
    #[validate(minimum = 1)]
    pub default_max_tokens: usize,

    /// Default capabilities granted to new agents
    ///
    /// These capabilities control which actions the agent is permitted to perform.
    pub default_capabilities: Vec<SistenceCapability>,
}

impl Default for SistenceProviderConfig {
    fn default() -> Self {
        Self {
            max_history_size: 100,
            default_temperature: 0.7,
            default_max_tokens: 500,
            default_capabilities: vec![SistenceCapability::Notify, SistenceCapability::Suggest],
        }
    }
}

impl From<&ProviderConfig> for SistenceProviderConfig {
    fn from(config: &ProviderConfig) -> Self {
        let kv = config_to_map(config);
        SistenceProviderConfigValidator::validate(&kv).unwrap_or_default()
    }
}

/// Validator for SistenceProvider configuration
///
/// This validator ensures that SistenceProvider configurations are valid,
/// checking for correct data types, value ranges, and capability names.
#[derive(Debug, Clone, Default)]
pub struct SistenceProviderConfigValidator;

impl SistenceProviderConfigValidator {
    /// Create a new validator for SistenceProvider configurations
    pub fn new() -> Self {
        Self
    }

    #[allow(clippy::result_large_err)]
    pub fn validate(
        config: &HashMap<String, serde_json::Value>,
    ) -> Result<SistenceProviderConfig, ProviderConfigError> {
        // First use the TypeCheckerValidator for basic schema validation
        let validator = TypeCheckerValidator;
        validator.validate_schema(config)?;

        // Convert HashMap to serde_json::Value
        let config_value =
            serde_json::Value::Object(config.iter().map(|(k, v)| (k.clone(), v.clone())).collect());

        // Try to deserialize the config into a SistenceProviderConfig
        match SistenceProviderConfig::from_json_value(config_value) {
            Ok(config) => Ok(config), // Validation successful - serde_validate handles the basic validation
            Err(err) => {
                // Get the first validation error and return it
                if let Some(validation_error) = err.as_validation_errors() {
                    Err(ProviderConfigError::Validation(
                        ValidationError::InvalidValue {
                            message: validation_error.to_string(),
                            context: ErrorContext::default(),
                        },
                    ))
                } else {
                    Err(ProviderConfigError::Validation(
                        ValidationError::invalid_value(
                            "config",
                            format!("Invalid configuration: {}", err),
                        ),
                    ))
                }
            }
        }
    }
}

/// Implementation of ProviderConfigValidator for SistenceProvider configuration
impl ProviderConfigValidator for SistenceProviderConfigValidator {
    fn validate_schema(
        &self,
        config: &HashMap<String, serde_json::Value>,
    ) -> Result<(), ProviderConfigError> {
        // First use the TypeCheckerValidator for basic schema validation
        let validator = TypeCheckerValidator;
        validator.validate_schema(config)?;
        SistenceProviderConfigValidator::validate(config).map(|_| ())
    }

    fn validate_capabilities(
        &self,
        _config: &HashMap<String, serde_json::Value>,
    ) -> Result<(), ProviderConfigError> {
        // No capabilities validation needed for SistenceProvider
        Ok(())
    }

    fn validate_dependencies(
        &self,
        _config: &HashMap<String, serde_json::Value>,
    ) -> Result<(), ProviderConfigError> {
        // No dependencies validation needed for SistenceProvider
        Ok(())
    }

    fn validate_schema_warnings(
        &self,
        config: &HashMap<String, serde_json::Value>,
    ) -> Vec<ProviderConfigError> {
        let mut warnings = Vec::new();

        // Convert HashMap to serde_json::Value
        let config_value =
            serde_json::Value::Object(config.iter().map(|(k, v)| (k.clone(), v.clone())).collect());

        // Try to deserialize the config into a SistenceProviderConfig
        if let Ok(config) = SistenceProviderConfig::from_json_value(config_value) {
            // Check for very large history size
            if config.max_history_size > 1000 {
                warnings.push(ProviderConfigError::Validation(
                    ValidationError::invalid_value(
                        "max_history_size",
                        format!(
                            "Large history size ({}) may impact memory usage and performance",
                            config.max_history_size
                        ),
                    ),
                ));
            }

            // Check for very high temperature
            if config.default_temperature > 0.9 {
                warnings.push(ProviderConfigError::Validation(
                    ValidationError::invalid_value(
                        "default_temperature",
                        "Very high temperature values may produce unpredictable results",
                    ),
                ));
            }
        }

        warnings
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_valid_config() {
        // Create a valid configuration
        let config = ProviderConfig::default();
        let mut config = config_to_map(&config);
        config.insert("max_history_size".to_string(), json!(100));
        config.insert("default_temperature".to_string(), json!(0.7));
        config.insert("default_max_tokens".to_string(), json!(500));
        config.insert(
            "default_capabilities".to_string(),
            json!(["Notify", "Suggest"]),
        );

        // Create validator
        let validator = SistenceProviderConfigValidator::new();

        // Validate schema
        validator.validate_schema(&config).unwrap();

        // Check warnings
        let warnings = validator.validate_schema_warnings(&config);
        assert!(
            warnings.is_empty(),
            "Valid configuration should not have warnings"
        );
    }

    #[test]
    fn test_invalid_config() {
        // Create an invalid configuration with zero max_history_size
        let mut config = HashMap::new();
        config.insert("max_history_size".to_string(), json!(0)); // Invalid: should be >= 1
        config.insert("default_temperature".to_string(), json!(0.7));
        config.insert("default_max_tokens".to_string(), json!(500));
        config.insert(
            "default_capabilities".to_string(),
            json!(["notify", "suggest"]),
        );

        // Create validator
        let validator = SistenceProviderConfigValidator::new();

        // Validate schema
        let result = validator.validate_schema(&config);
        assert!(
            result.is_err(),
            "Invalid max_history_size should fail validation"
        );
        assert!(result.is_err());

        // Create an invalid configuration with out-of-range temperature
        let mut config = HashMap::new();
        config.insert("max_history_size".to_string(), json!(100));
        config.insert("default_temperature".to_string(), json!(1.5)); // Invalid: should be <= 1.0
        config.insert("default_max_tokens".to_string(), json!(500));
        config.insert(
            "default_capabilities".to_string(),
            json!(["notify", "suggest"]),
        );

        // Validate schema
        let result = validator.validate_schema(&config);
        assert!(result.is_err());

        // Create an invalid configuration with zero max_tokens
        let config = ProviderConfig::default();
        let mut config = config_to_map(&config);
        config.insert("max_history_size".to_string(), json!(100));
        config.insert("default_temperature".to_string(), json!(0.7));
        config.insert("default_max_tokens".to_string(), json!(0)); // Invalid: should be >= 1
        config.insert(
            "default_capabilities".to_string(),
            json!(["Notify", "Suggest"]),
        );

        // Validate schema
        let result = validator.validate_schema(&config);
        assert!(result.is_err(), "Invalid max_tokens should fail validation");
        assert!(result.is_err());
    }

    #[test]
    fn test_warning_config() {
        // Create a configuration that should generate warnings
        let config = ProviderConfig::default();
        let mut config = config_to_map(&config);
        config.insert("max_history_size".to_string(), json!(2000)); // Warning: > 1000
        config.insert("default_temperature".to_string(), json!(0.95)); // Warning: > 0.9
        config.insert("default_max_tokens".to_string(), json!(500));
        config.insert(
            "default_capabilities".to_string(),
            json!(["Notify", "Suggest"]),
        );

        // Create validator
        let validator = SistenceProviderConfigValidator::new();

        // Validate schema
        let result = validator.validate_schema(&config);
        assert!(
            result.is_ok(),
            "Configuration with warning thresholds should still be valid"
        );

        // Check warnings
        let warnings = validator.validate_schema_warnings(&config);
        assert_eq!(warnings.len(), 2, "Should have 2 warnings");
        assert!(warnings[0].to_string().contains("max_history_size"));
        assert!(warnings[1].to_string().contains("temperature"));
    }

    #[test]
    fn test_serde_validate_integration() {
        // Test that serde_validate attributes are working correctly

        // Valid config
        let config = SistenceProviderConfig {
            max_history_size: 100,
            default_temperature: 0.7,
            default_max_tokens: 500,
            default_capabilities: vec![SistenceCapability::Notify, SistenceCapability::Suggest],
        };

        // Validate using serde_valid directly
        let result = config.validate();
        assert!(
            result.is_ok(),
            "Valid config should pass serde_valid validation"
        );

        // Invalid max_history_size
        let invalid_config = SistenceProviderConfig {
            max_history_size: 0, // Invalid: should be >= 1
            default_temperature: 0.7,
            default_max_tokens: 500,
            default_capabilities: vec![SistenceCapability::Notify, SistenceCapability::Suggest],
        };

        let result = invalid_config.validate();
        assert!(
            result.is_err(),
            "Invalid max_history_size should fail serde_valid validation"
        );

        // Invalid temperature
        let invalid_config = SistenceProviderConfig {
            max_history_size: 100,
            default_temperature: 1.5, // Invalid: should be <= 1.0
            default_max_tokens: 500,
            default_capabilities: vec![SistenceCapability::Notify, SistenceCapability::Suggest],
        };

        let result = invalid_config.validate();
        assert!(
            result.is_err(),
            "Invalid temperature should fail serde_valid validation"
        );
    }
}
